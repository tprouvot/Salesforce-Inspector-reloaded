import{Transport as e}from"./Transport.js";export class RequestTransport extends e{#a=0;#b=null;#c=[];#d=[];#e(t){for(;this.#d.length>0;){let s=this.#d[0],i=s[0],r=s[1];if(i.url===t.url&&i.sync===t.sync){this.#d.shift(),t.messages=t.messages.concat(i.messages),this.debug("Coalesced",i.messages.length,"messages from request",r.id);continue}break}}#f(n,o,a){let h=this.notifyTransportTimeout(n.messages);if(h>0)this.debug("Transport",this.type,"extended waiting for message replies of request",o.id,":",h,"ms"),o.timeout=this.setTimeout(()=>{this.#f(n,o,a+h)},h);else{o.expired=!0;let u="Transport "+this+" expired waiting for message replies of request "+o.id+": "+a+" ms",l={reason:u},p=o.xhr;l.httpCode=this.xhrStatus(p),this.abortXHR(p),this.debug(u),this.complete(o,!1,o.metaConnect),n.onFailure(p,n.messages,l)}}#g(c,m){if(this.transportSend(c,m)&&(m.expired=!1,!c.sync)){let d=this.configuration.maxNetworkDelay;!0===m.metaConnect&&(d+=this.advice.timeout),this.debug("Transport",this.type,"started waiting for message replies of request",m.id,":",d,"ms"),m.timeout=this.setTimeout(()=>{this.#f(c,m,d)},d)}}#h(g){let q=++this.#a,f={id:q,metaConnect:!1,envelope:g};this.#c.length<this.configuration.maxConnections-1?(this.#c.push(f),this.#g(g,f)):(this.debug("Transport",this.type,"queueing request",q,"envelope",g),this.#d.push([g,f]))}#i(b){let C=b.id;if(this.debug("Transport",this.type,"/meta/connect complete, request",C),null!==this.#b&&this.#b.id!==C)throw Error("/meta/connect request mismatch, completing request "+C);this.#b=null}#j(T,x){let y=this.#c.indexOf(T);if(y>=0&&this.#c.splice(y,1),this.#d.length>0){let $=this.#d.shift(),v=$[0],R=$[1];this.debug("Transport dequeued request",R.id),x?(this.configuration.autoBatch&&this.#e(v),this.#h(v),this.debug("Transport",this.type,"completed request",T.id,v)):this.setTimeout(()=>{this.complete(R,!1,R.metaConnect);let e={reason:"Previous request failed"},t=R.xhr;e.httpCode=this.xhrStatus(t),v.onFailure(t,v.messages,e)},0)}}complete(e,t,s){s?this.#i(e):this.#j(e,t)}transportSend(e,t){throw Error("Abstract")}transportSuccess(e,t,s){t.expired||(this.clearTimeout(t.timeout),this.debug("Transport",this.type,"cancelled waiting for message replies"),this.complete(t,!0,t.metaConnect),s&&s.length>0?e.onSuccess(s):e.onFailure(t.xhr,e.messages,{httpCode:204}))}transportFailure(e,t,s){t.expired||(this.clearTimeout(t.timeout),this.debug("Transport",this.type,"cancelled waiting for failed message replies"),this.complete(t,!1,t.metaConnect),e.onFailure(t.xhr,e.messages,s))}#k(S){if(null!==this.#b)throw Error("Concurrent /meta/connect requests not allowed, request id="+this.#b.id+" not yet completed");let _=++this.#a;this.debug("Transport",this.type,"/meta/connect send, request",_,"envelope",S);let w={id:_,metaConnect:!0,envelope:S};this.#g(S,w),this.#b=w}send(e,t){t?this.#k(e):this.#h(e)}abort(){super.abort();for(let e=0;e<this.#c.length;++e){let t=this.#c[e];t&&(this.debug("Aborting request",t),this.abortXHR(t.xhr)||this.transportFailure(t.envelope,t,{reason:"abort"}))}let s=this.#b;s&&(this.debug("Aborting /meta/connect request",s),this.abortXHR(s.xhr)||this.transportFailure(s.envelope,s,{reason:"abort"})),this.reset(!0)}reset(e){super.reset(e),this.#b=null,this.#c=[],this.#d=[]}abortXHR(e){if(e)try{let t=e.readyState;return e.abort(),t!==window.XMLHttpRequest.UNSENT}catch(s){this.debug(s)}return!1}xhrStatus(e){if(e)try{return e.status}catch(t){this.debug(t)}return -1}}
